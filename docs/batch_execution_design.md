# åç»­æ‰¹æ¬¡è‡ªåŠ¨è§¦å‘å®ç°æ–¹æ¡ˆ

## ğŸ“‹ éœ€æ±‚åˆ†æ

å½“å‰çŠ¶æ€ï¼š
- âœ… å»ºä»“ç­–ç•¥å·²ç”Ÿæˆï¼ˆåŒ…å«å¤šæ‰¹æ¬¡è®¡åˆ’ï¼‰
- âœ… ç¬¬1æ‰¹å·²æ‰§è¡Œ
- âŒ ç¬¬2ã€3æ‰¹éœ€è¦ä»·æ ¼è§¦å‘æ—¶è‡ªåŠ¨æ‰§è¡Œ

ç›®æ ‡ï¼š
- ç›‘æ§å¸‚åœºä»·æ ¼
- å½“ä»·æ ¼è¾¾åˆ°è§¦å‘æ¡ä»¶æ—¶ï¼Œè‡ªåŠ¨æ‰§è¡Œå¯¹åº”æ‰¹æ¬¡
- æ›´æ–°æ‰¹æ¬¡çŠ¶æ€
- è®°å½•æ‰§è¡Œæ—¥å¿—

---

## ğŸ¯ è®¾è®¡æ–¹æ¡ˆ

### æ–¹æ¡ˆä¸€ï¼šå®šæ—¶è½®è¯¢ï¼ˆæ¨èï¼‰

**åŸç†**ï¼š
- å¯åŠ¨ä¸€ä¸ªåå° goroutine
- æ¯éš” N ç§’æ£€æŸ¥ä¸€æ¬¡æ‰€æœ‰å¾…æ‰§è¡Œæ‰¹æ¬¡
- å¯¹æ¯”å½“å‰ä»·æ ¼ä¸è§¦å‘ä»·æ ¼
- æ»¡è¶³æ¡ä»¶åˆ™æ‰§è¡Œ

**ä¼˜ç‚¹**ï¼š
- âœ… å®ç°ç®€å•
- âœ… å¯æ§æ€§å¼º
- âœ… æ˜“äºè°ƒè¯•
- âœ… èµ„æºå ç”¨ä½

**ç¼ºç‚¹**ï¼š
- âŒ æœ‰å»¶è¿Ÿï¼ˆæœ€å¤š N ç§’ï¼‰
- âŒ å¯èƒ½é”™è¿‡ç¬é—´ä»·æ ¼

**é€‚ç”¨åœºæ™¯**ï¼š
- ç°è´§äº¤æ˜“ï¼ˆä»·æ ¼å˜åŒ–ç›¸å¯¹å¹³ç¼“ï¼‰
- åˆ†é’Ÿçº§è§¦å‘ç²¾åº¦è¦æ±‚

---

### æ–¹æ¡ˆäºŒï¼šWebSocket å®æ—¶ç›‘æ§

**åŸç†**ï¼š
- è¿æ¥ Binance WebSocket
- è®¢é˜…ä»·æ ¼æµ
- å®æ—¶æ¥æ”¶ä»·æ ¼æ›´æ–°
- ç«‹å³åˆ¤æ–­å¹¶æ‰§è¡Œ

**ä¼˜ç‚¹**ï¼š
- âœ… å®æ—¶æ€§å¼ºï¼ˆæ¯«ç§’çº§ï¼‰
- âœ… ä¸ä¼šé”™è¿‡ä»·æ ¼
- âœ… èµ„æºæ•ˆç‡é«˜ï¼ˆæ¨é€æ¨¡å¼ï¼‰

**ç¼ºç‚¹**ï¼š
- âŒ å®ç°å¤æ‚
- âŒ éœ€è¦å¤„ç†è¿æ¥æ–­å¼€é‡è¿
- âŒ éœ€è¦ç®¡ç†è®¢é˜…åˆ—è¡¨

**é€‚ç”¨åœºæ™¯**ï¼š
- åˆçº¦äº¤æ˜“ï¼ˆä»·æ ¼æ³¢åŠ¨å¤§ï¼‰
- ç§’çº§è§¦å‘ç²¾åº¦è¦æ±‚

---

### æ–¹æ¡ˆä¸‰ï¼šæ··åˆæ–¹æ¡ˆ

**åŸç†**ï¼š
- å®šæ—¶è½®è¯¢ä½œä¸ºä¸»è¦æœºåˆ¶
- WebSocket ä½œä¸ºè¾…åŠ©ï¼ˆå¯é€‰ï¼‰
- ä¼˜å…ˆä½¿ç”¨ WebSocketï¼Œé™çº§åˆ°è½®è¯¢

**ä¼˜ç‚¹**ï¼š
- âœ… å…¼é¡¾å®æ—¶æ€§å’Œç¨³å®šæ€§
- âœ… å®¹é”™èƒ½åŠ›å¼º

**ç¼ºç‚¹**ï¼š
- âŒ å®ç°æœ€å¤æ‚

---

## ğŸš€ æ¨èå®ç°ï¼šæ–¹æ¡ˆä¸€ï¼ˆå®šæ—¶è½®è¯¢ï¼‰

### æ¶æ„è®¾è®¡

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚          BatchExecutor Service                  â”‚
â”‚  (åå° goroutineï¼Œæ¯30ç§’è¿è¡Œä¸€æ¬¡)               â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                 â”‚
                 â–¼
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚ 1. æŸ¥è¯¢æ‰€æœ‰å¾…æ‰§è¡Œæ‰¹æ¬¡   â”‚
    â”‚    (status = pending)  â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
             â”‚
             â–¼
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚ 2. è·å–å½“å‰å¸‚åœºä»·æ ¼     â”‚
    â”‚    (Binance API)       â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
             â”‚
             â–¼
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚ 3. åˆ¤æ–­è§¦å‘æ¡ä»¶         â”‚
    â”‚    price <= trigger?   â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
             â”‚
        â”Œâ”€â”€â”€â”€â”´â”€â”€â”€â”€â”
        â”‚ æ»¡è¶³ï¼Ÿ   â”‚
        â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”˜
             â”‚
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚ æ˜¯              â”‚ å¦
    â–¼                 â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ æ‰§è¡Œ   â”‚      â”‚ ç»§ç»­ç­‰å¾…  â”‚
â”‚ è®¢å•   â”‚      â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
â””â”€â”€â”€â”¬â”€â”€â”€â”€â”˜
    â”‚
    â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ æ›´æ–°æ‰¹æ¬¡çŠ¶æ€   â”‚
â”‚ executed       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## ğŸ’» å®ç°ä»£ç 

### 1. æ•°æ®åº“æŸ¥è¯¢æ–¹æ³•

```go
// internal/store/position_strategy.go

// ListPendingBatches è·å–æ‰€æœ‰å¾…æ‰§è¡Œçš„æ‰¹æ¬¡
func (r *SQLiteRepository) ListPendingBatches(ctx context.Context) ([]PendingBatch, error) {
	rows, err := r.db.QueryContext(ctx, `
		SELECT 
			ps.id as strategy_id,
			ps.cycle_id,
			ps.pair,
			ps.batches
		FROM position_strategies ps
		WHERE EXISTS (
			SELECT 1 FROM json_each(ps.batches)
			WHERE json_extract(value, '$.status') = 'pending'
		)
	`)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var batches []PendingBatch
	for rows.Next() {
		var pb PendingBatch
		var batchesJSON string
		if err := rows.Scan(&pb.StrategyID, &pb.CycleID, &pb.Pair, &batchesJSON); err != nil {
			return nil, err
		}
		
		// è§£ææ‰¹æ¬¡æ•°æ®
		var allBatches []domain.PositionBatch
		if err := json.Unmarshal([]byte(batchesJSON), &allBatches); err != nil {
			return nil, err
		}
		
		// åªä¿ç•™ pending çŠ¶æ€çš„æ‰¹æ¬¡
		for _, b := range allBatches {
			if b.Status == "pending" {
				pb.Batches = append(pb.Batches, b)
			}
		}
		
		if len(pb.Batches) > 0 {
			batches = append(batches, pb)
		}
	}
	return batches, nil
}

// UpdateBatchStatus æ›´æ–°æ‰¹æ¬¡çŠ¶æ€
func (r *SQLiteRepository) UpdateBatchStatus(ctx context.Context, strategyID string, batchNo int, status string, executedPrice, executedQty float64, executedAt time.Time) error {
	// 1. è¯»å–å½“å‰ç­–ç•¥
	strategy, err := r.GetPositionStrategy(ctx, strategyID)
	if err != nil {
		return err
	}
	
	// 2. æ›´æ–°å¯¹åº”æ‰¹æ¬¡
	for i := range strategy.Batches {
		if strategy.Batches[i].BatchNo == batchNo {
			strategy.Batches[i].Status = status
			strategy.Batches[i].ExecutedPrice = executedPrice
			strategy.Batches[i].ExecutedQty = executedQty
			strategy.Batches[i].ExecutedAt = &executedAt
			break
		}
	}
	
	// 3. åºåˆ—åŒ–å¹¶æ›´æ–°
	batchesJSON, err := json.Marshal(strategy.Batches)
	if err != nil {
		return err
	}
	
	_, err = r.db.ExecContext(ctx, `
		UPDATE position_strategies
		SET batches = ?
		WHERE id = ?
	`, string(batchesJSON), strategyID)
	
	return err
}

type PendingBatch struct {
	StrategyID string
	CycleID    string
	Pair       string
	Batches    []domain.PositionBatch
}
```

### 2. æ‰¹æ¬¡æ‰§è¡ŒæœåŠ¡

```go
// internal/executor/batch_executor.go

package executor

import (
	"context"
	"log"
	"strings"
	"time"

	"ai_quant/internal/agent/execution"
	"ai_quant/internal/domain"
	"ai_quant/internal/store"
)

type BatchExecutor struct {
	repo     store.Repository
	executor execution.Executor
	interval time.Duration
	stopCh   chan struct{}
}

func NewBatchExecutor(repo store.Repository, executor execution.Executor, intervalSec int) *BatchExecutor {
	return &BatchExecutor{
		repo:     repo,
		executor: executor,
		interval: time.Duration(intervalSec) * time.Second,
		stopCh:   make(chan struct{}),
	}
}

// Start å¯åŠ¨æ‰¹æ¬¡æ‰§è¡Œå™¨
func (be *BatchExecutor) Start(ctx context.Context) {
	ticker := time.NewTicker(be.interval)
	defer ticker.Stop()

	log.Printf("[æ‰¹æ¬¡æ‰§è¡Œå™¨] å·²å¯åŠ¨ æ£€æŸ¥é—´éš”=%s", be.interval)

	for {
		select {
		case <-ticker.C:
			be.checkAndExecute(ctx)
		case <-be.stopCh:
			log.Println("[æ‰¹æ¬¡æ‰§è¡Œå™¨] å·²åœæ­¢")
			return
		case <-ctx.Done():
			log.Println("[æ‰¹æ¬¡æ‰§è¡Œå™¨] ä¸Šä¸‹æ–‡å–æ¶ˆ")
			return
		}
	}
}

// Stop åœæ­¢æ‰¹æ¬¡æ‰§è¡Œå™¨
func (be *BatchExecutor) Stop() {
	close(be.stopCh)
}

// checkAndExecute æ£€æŸ¥å¹¶æ‰§è¡Œå¾…è§¦å‘æ‰¹æ¬¡
func (be *BatchExecutor) checkAndExecute(ctx context.Context) {
	// 1. è·å–æ‰€æœ‰å¾…æ‰§è¡Œæ‰¹æ¬¡
	pendingBatches, err := be.repo.ListPendingBatches(ctx)
	if err != nil {
		log.Printf("[æ‰¹æ¬¡æ‰§è¡Œå™¨] âš  æŸ¥è¯¢å¾…æ‰§è¡Œæ‰¹æ¬¡å¤±è´¥: %v", err)
		return
	}

	if len(pendingBatches) == 0 {
		return
	}

	log.Printf("[æ‰¹æ¬¡æ‰§è¡Œå™¨] æ£€æŸ¥ %d ä¸ªå¾…æ‰§è¡Œæ‰¹æ¬¡", len(pendingBatches))

	// 2. éå†æ¯ä¸ªæ‰¹æ¬¡
	for _, pb := range pendingBatches {
		// 3. è·å–å½“å‰ä»·æ ¼
		currentPrice, err := be.getCurrentPrice(ctx, pb.Pair)
		if err != nil {
			log.Printf("[æ‰¹æ¬¡æ‰§è¡Œå™¨] âš  è·å– %s ä»·æ ¼å¤±è´¥: %v", pb.Pair, err)
			continue
		}

		// 4. æ£€æŸ¥æ¯ä¸ªæ‰¹æ¬¡æ˜¯å¦æ»¡è¶³è§¦å‘æ¡ä»¶
		for _, batch := range pb.Batches {
			if be.shouldExecute(batch, currentPrice) {
				log.Printf("[æ‰¹æ¬¡æ‰§è¡Œå™¨] ğŸ¯ è§¦å‘æ‰¹æ¬¡ %s ç¬¬%dæ‰¹ è§¦å‘ä»·=%.6f å½“å‰ä»·=%.6f",
					pb.Pair, batch.BatchNo, batch.TriggerPrice, currentPrice)
				
				// 5. æ‰§è¡Œè®¢å•
				if err := be.executeBatch(ctx, pb, batch, currentPrice); err != nil {
					log.Printf("[æ‰¹æ¬¡æ‰§è¡Œå™¨] âœ˜ æ‰§è¡Œå¤±è´¥: %v", err)
				} else {
					log.Printf("[æ‰¹æ¬¡æ‰§è¡Œå™¨] âœ” æ‰¹æ¬¡ %d æ‰§è¡ŒæˆåŠŸ", batch.BatchNo)
				}
			}
		}
	}
}

// shouldExecute åˆ¤æ–­æ˜¯å¦åº”è¯¥æ‰§è¡Œæ‰¹æ¬¡
func (be *BatchExecutor) shouldExecute(batch domain.PositionBatch, currentPrice float64) bool {
	// ä¹°å…¥ï¼šå½“å‰ä»·æ ¼ <= è§¦å‘ä»·æ ¼ï¼ˆä»·æ ¼ä¸‹è·Œåˆ°ç›®æ ‡ä½ï¼‰
	return currentPrice <= batch.TriggerPrice
}

// getCurrentPrice è·å–å½“å‰å¸‚åœºä»·æ ¼
func (be *BatchExecutor) getCurrentPrice(ctx context.Context, pair string) (float64, error) {
	// ä½¿ç”¨ Binance API è·å–å®æ—¶ä»·æ ¼
	symbol := strings.Replace(pair, "/", "", 1)
	
	// ç®€åŒ–ç‰ˆï¼šç›´æ¥è°ƒç”¨ ticker API
	// å®é™…åº”è¯¥å¤ç”¨ orchestrator ä¸­çš„ fetchTickerPrice æ–¹æ³•
	url := "https://api.binance.com/api/v3/ticker/price?symbol=" + symbol
	
	var result struct {
		Price string `json:"price"`
	}
	
	// HTTP è¯·æ±‚è·å–ä»·æ ¼ï¼ˆçœç•¥å…·ä½“å®ç°ï¼‰
	// ...
	
	return parseFloat(result.Price), nil
}

// executeBatch æ‰§è¡Œæ‰¹æ¬¡è®¢å•
func (be *BatchExecutor) executeBatch(ctx context.Context, pb store.PendingBatch, batch domain.PositionBatch, currentPrice float64) error {
	// 1. æ„é€ æ‰§è¡Œè¾“å…¥
	execInput := execution.Input{
		CycleID:       pb.CycleID,
		SignalID:      "", // æ‰¹æ¬¡æ‰§è¡Œæ²¡æœ‰æ–°çš„ signal
		Pair:          pb.Pair,
		Side:          domain.SideLong,
		StakeUSDT:     batch.Amount,
		EstimatedFill: currentPrice,
	}

	// 2. æ‰§è¡Œè®¢å•
	order, err := be.executor.Execute(ctx, execInput)
	if err != nil {
		return err
	}

	// 3. æ›´æ–°æ‰¹æ¬¡çŠ¶æ€
	now := time.Now().UTC()
	err = be.repo.UpdateBatchStatus(
		ctx,
		pb.StrategyID,
		batch.BatchNo,
		"executed",
		order.FilledPrice,
		order.FilledQuantity,
		now,
	)
	if err != nil {
		log.Printf("[æ‰¹æ¬¡æ‰§è¡Œå™¨] âš  æ›´æ–°æ‰¹æ¬¡çŠ¶æ€å¤±è´¥: %v", err)
	}

	// 4. è®°å½•æ—¥å¿—
	log.Printf("[æ‰¹æ¬¡æ‰§è¡Œå™¨] æ‰¹æ¬¡ %d å·²æ‰§è¡Œ ä»·æ ¼=%.6f æ•°é‡=%.4f é‡‘é¢=%.2f",
		batch.BatchNo, order.FilledPrice, order.FilledQuantity, batch.Amount)

	return nil
}
```

### 3. é›†æˆåˆ°ä¸»ç¨‹åº

```go
// main.go

import (
	"ai_quant/internal/executor"
)

func main() {
	// ... ç°æœ‰åˆå§‹åŒ–ä»£ç  ...

	// åˆå§‹åŒ–æ‰¹æ¬¡æ‰§è¡Œå™¨
	batchExecutor := executor.NewBatchExecutor(repo, execAgent, 30) // æ¯30ç§’æ£€æŸ¥ä¸€æ¬¡
	
	// å¯åŠ¨æ‰¹æ¬¡æ‰§è¡Œå™¨ï¼ˆåå°è¿è¡Œï¼‰
	go batchExecutor.Start(context.Background())
	log.Println("ğŸ“¦ æ‰¹æ¬¡æ‰§è¡Œå™¨å·²å¯åŠ¨")

	// ... HTTP æœåŠ¡å™¨å¯åŠ¨ ...
}
```

---

## ğŸ›ï¸ é…ç½®é€‰é¡¹

åœ¨ `.env` ä¸­æ·»åŠ ï¼š

```bash
# æ‰¹æ¬¡æ‰§è¡Œå™¨é…ç½®
BATCH_EXECUTOR_ENABLED=true      # æ˜¯å¦å¯ç”¨
BATCH_EXECUTOR_INTERVAL_SEC=30   # æ£€æŸ¥é—´éš”ï¼ˆç§’ï¼‰
```

åœ¨ `config.go` ä¸­æ·»åŠ ï¼š

```go
type Config struct {
	// ... ç°æœ‰å­—æ®µ ...
	
	// æ‰¹æ¬¡æ‰§è¡Œå™¨
	BatchExecutorEnabled    bool
	BatchExecutorIntervalSec int
}

func Load() Config {
	// ... ç°æœ‰ä»£ç  ...
	
	cfg.BatchExecutorEnabled = getEnvBool("BATCH_EXECUTOR_ENABLED", true)
	cfg.BatchExecutorIntervalSec = getEnvInt("BATCH_EXECUTOR_INTERVAL_SEC", 30)
	
	return cfg
}
```

---

## ğŸ“Š ç›‘æ§å’Œæ—¥å¿—

### æ—¥å¿—ç¤ºä¾‹

```
[æ‰¹æ¬¡æ‰§è¡Œå™¨] å·²å¯åŠ¨ æ£€æŸ¥é—´éš”=30s
[æ‰¹æ¬¡æ‰§è¡Œå™¨] æ£€æŸ¥ 2 ä¸ªå¾…æ‰§è¡Œæ‰¹æ¬¡
[æ‰¹æ¬¡æ‰§è¡Œå™¨] ğŸ¯ è§¦å‘æ‰¹æ¬¡ DOGE/USDT ç¬¬2æ‰¹ è§¦å‘ä»·=0.104763 å½“å‰ä»·=0.104500
[æ‰¹æ¬¡æ‰§è¡Œå™¨] ğŸ’¸ æ‰§è¡Œ: æ­£åœ¨ä¸‹å• DOGE/USDT long 15.00 USDT ...
[æ‰¹æ¬¡æ‰§è¡Œå™¨] âœ” æ‰¹æ¬¡ 2 æ‰§è¡ŒæˆåŠŸ
[æ‰¹æ¬¡æ‰§è¡Œå™¨] æ‰¹æ¬¡ 2 å·²æ‰§è¡Œ ä»·æ ¼=0.104500 æ•°é‡=143.54 é‡‘é¢=15.00
```

### ç›‘æ§æŒ‡æ ‡

- å¾…æ‰§è¡Œæ‰¹æ¬¡æ•°é‡
- è§¦å‘æ‰§è¡Œæ¬¡æ•°
- æ‰§è¡ŒæˆåŠŸ/å¤±è´¥ç‡
- å¹³å‡æ‰§è¡Œå»¶è¿Ÿ

---

## ğŸ”’ å®‰å…¨è€ƒè™‘

### 1. é˜²æ­¢é‡å¤æ‰§è¡Œ

```go
// åœ¨ UpdateBatchStatus å‰åŠ é”
var batchLocks sync.Map

func (be *BatchExecutor) executeBatch(...) error {
	lockKey := fmt.Sprintf("%s_%d", pb.StrategyID, batch.BatchNo)
	
	// å°è¯•è·å–é”
	if _, loaded := batchLocks.LoadOrStore(lockKey, true); loaded {
		return errors.New("æ‰¹æ¬¡æ­£åœ¨æ‰§è¡Œä¸­")
	}
	defer batchLocks.Delete(lockKey)
	
	// ... æ‰§è¡Œé€»è¾‘ ...
}
```

### 2. ä»·æ ¼æ»‘ç‚¹ä¿æŠ¤

```go
func (be *BatchExecutor) shouldExecute(batch domain.PositionBatch, currentPrice float64) bool {
	// å…è®¸ 0.5% çš„æ»‘ç‚¹
	maxPrice := batch.TriggerPrice * 1.005
	return currentPrice <= maxPrice
}
```

### 3. ä½™é¢æ£€æŸ¥

```go
func (be *BatchExecutor) executeBatch(...) error {
	// æ‰§è¡Œå‰æ£€æŸ¥ USDT ä½™é¢
	balances, err := be.executor.FetchFullBalance(ctx)
	// ... ä½™é¢ä¸è¶³åˆ™è·³è¿‡ ...
}
```

---

## ğŸš€ ä¼˜åŒ–å»ºè®®

### 1. æ‰¹é‡è·å–ä»·æ ¼

```go
// ä¸€æ¬¡æ€§è·å–æ‰€æœ‰éœ€è¦çš„äº¤æ˜“å¯¹ä»·æ ¼
prices := be.getBatchPrices(ctx, uniquePairs)
```

### 2. ä¼˜å…ˆçº§é˜Ÿåˆ—

```go
// æŒ‰è§¦å‘ä»·æ ¼æ’åºï¼Œä¼˜å…ˆæ£€æŸ¥æ¥è¿‘è§¦å‘çš„æ‰¹æ¬¡
sort.Slice(batches, func(i, j int) bool {
	return batches[i].TriggerPrice > batches[j].TriggerPrice
})
```

### 3. åŠ¨æ€è°ƒæ•´é—´éš”

```go
// æœ‰å¾…æ‰§è¡Œæ‰¹æ¬¡æ—¶ï¼Œç¼©çŸ­æ£€æŸ¥é—´éš”
if len(pendingBatches) > 0 {
	ticker.Reset(10 * time.Second)
} else {
	ticker.Reset(60 * time.Second)
}
```

---

## ğŸ“ˆ æœªæ¥å¢å¼º

1. **WebSocket å®æ—¶ç›‘æ§**ï¼ˆæ–¹æ¡ˆäºŒï¼‰
2. **æ­¢ç›ˆæ­¢æŸè‡ªåŠ¨è§¦å‘**
3. **æ‰¹æ¬¡æ‰§è¡Œé€šçŸ¥**ï¼ˆé‚®ä»¶/Webhookï¼‰
4. **æ‰¹æ¬¡æ‰§è¡Œå†å²ç»Ÿè®¡**
5. **æ‰‹åŠ¨å–æ¶ˆå¾…æ‰§è¡Œæ‰¹æ¬¡**

---

## æ€»ç»“

**æ¨èæ–¹æ¡ˆ**ï¼šå®šæ—¶è½®è¯¢ï¼ˆ30ç§’é—´éš”ï¼‰

**å®ç°æ­¥éª¤**ï¼š
1. âœ… æ·»åŠ æ•°æ®åº“æŸ¥è¯¢æ–¹æ³•
2. âœ… åˆ›å»º BatchExecutor æœåŠ¡
3. âœ… é›†æˆåˆ° main.go
4. âœ… æ·»åŠ é…ç½®é€‰é¡¹
5. âœ… æµ‹è¯•éªŒè¯

**ä¼˜ç‚¹**ï¼š
- å®ç°ç®€å•ï¼Œæ˜“äºç»´æŠ¤
- èµ„æºå ç”¨ä½
- æ»¡è¶³ç°è´§äº¤æ˜“éœ€æ±‚

**ä¸‹ä¸€æ­¥**ï¼š
- å®ç°ä»£ç 
- å•å…ƒæµ‹è¯•
- é›†æˆæµ‹è¯•
- ç”Ÿäº§éªŒè¯
